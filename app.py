from fastapi import FastAPI, HTTPException, Query, Depends
from motor.motor_asyncio import AsyncIOMotorClient
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime, timezone
import os
from dotenv import load_dotenv
import requests

app = FastAPI(title="FastAPI Chat Service with MongoDB")

# Load environment variables
load_dotenv()
MONGO_URI = os.getenv("MONGO_URI", "mongodb://localhost:27017")
client = AsyncIOMotorClient(MONGO_URI)
db = client[os.getenv("DATABASE_NAME", "chatdb")]
messages_collection = db["messages"]


# Database Schema (messages collection)
"""
{
  "_id": ObjectId,       # Auto-generated by MongoDB
  "conversation_id": str, # Unique identifier for the conversation
  "user_id": str,        # Identifier for the user who sent the message
  "content": str,        # The chat message content
  "timestamp": datetime  # Timestamp of the message
}
"""


# Pydantic Models
class ChatMessage(BaseModel):
    conversation_id: str
    user_id: str
    content: str
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class MessageResponse(BaseModel):
    message_id: str
    conversation_id: str
    user_id: str
    content: str
    timestamp: datetime


# Creating API Endpoints

@app.post("/chats", response_model=MessageResponse)
async def store_chat_message(chat: ChatMessage):

    #Store a chat message in the database.
    message_doc = {
        "conversation_id": chat.conversation_id,
        "user_id": chat.user_id,
        "content": chat.content,
        "timestamp": chat.timestamp,
    }
    result = await messages_collection.insert_one(message_doc)

    # Prepare response
    message_doc["message_id"] = str(result.inserted_id)
    return message_doc

@app.get("/chats/{conversation_id}", response_model=List[MessageResponse])
async def retrieve_chat_messages(
    conversation_id: str,
    keyword: Optional[str] = Query(None, description="Filter messages containing this keyword"),
    start_date: Optional[datetime] = Query(None, description="Start date for filtering messages"),
    end_date: Optional[datetime] = Query(None, description="End date for filtering messages"),
    limit: int = Query(50, ge=1, le=100, description="Limit number of messages to fetch")
):

    # Retrieve messages from a specific conversation, with optional keyword and date filters.

    query = {"conversation_id": conversation_id}

    if keyword:
        query["$text"] = {"$search": keyword}  # Text search on content

    if start_date or end_date:
        date_filter = {}
        if start_date:
            date_filter["$gte"] = start_date
        if end_date:
            date_filter["$lte"] = end_date
        query["timestamp"] = date_filter

    messages = []
    async for message in messages_collection.find(query).sort("timestamp", -1).limit(limit):
        message["message_id"] = str(message["_id"])
        messages.append(message)

    if not messages:
        raise HTTPException(status_code=404, detail="No messages found")

    return messages

@app.get("/users/{user_id}/chats", response_model=List[MessageResponse])
async def get_user_chat_history(
    user_id: str,
    page: int = Query(1, ge=1, description="Page number"),
    limit: int = Query(10, ge=1, le=50, description="Messages per page")
):

    # Retrieve a paginated list of chat messages for a given user.

    skip = (page - 1) * limit
    query = {"user_id": user_id}

    messages = []
    async for message in messages_collection.find(query).sort("timestamp", -1).skip(skip).limit(limit):
        message["message_id"] = str(message["_id"])
        messages.append(message)

    if not messages:
        raise HTTPException(status_code=404, detail="No chat history found for this user")

    return messages

@app.delete("/chats/{conversation_id}")
async def delete_chat(conversation_id: str):

    # Delete an entire conversation and all its messages.

    delete_result = await messages_collection.delete_many({"conversation_id": conversation_id})

    if delete_result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Conversation not found")

    return {"message": f"Deleted {delete_result.deleted_count} messages from conversation '{conversation_id}'"}

# ---------------------------


# Indexes Creation at Startup
@app.on_event("startup")
async def setup_indexes() -> None:
    await messages_collection.create_index([("conversation_id", 1)])  # For fast retrieval of chats
    await messages_collection.create_index([("user_id", 1)])          # Optimized search by user
    await messages_collection.create_index([("timestamp", -1)])       # Speed up filtering & sorting
    await messages_collection.create_index([("content", "text")])     # Enables keyword search
