from fastapi import FastAPI, HTTPException, Query, Depends
from motor.motor_asyncio import AsyncIOMotorClient
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime, timezone
import os
from dotenv import load_dotenv
import requests
import unicodedata

app = FastAPI(title="FastAPI Chat Service with MongoDB")

# Load environment variables
load_dotenv()
MONGO_URI = os.getenv("MONGO_URI", "mongodb://localhost:27017")
client = AsyncIOMotorClient(MONGO_URI, tlsCAFile=None, tlsAllowInvalidCertificates=True)
db = client[os.getenv("DATABASE_NAME", "chatdb")]
messages_collection = db["messages"]
summaries_collection = db["summaries"]
HF_API_KEY = os.getenv("HF_API_KEY")


# Database Schema 
# messages collection
"""
{
  "_id": ObjectId,       # Auto-generated by MongoDB
  "conversation_id": str, # Unique identifier for the conversation
  "user_id": str,        # Identifier for the user who sent the message
  "content": str,        # The chat message content
  "timestamp": datetime  # Timestamp of the message
}
"""

# summaries_collection
"""
{
  "_id": ObjectId,       # Auto-generated by MongoDB
  "conversation_id": str, # Unique identifier for the conversation
  "summary_text": str,    # Summarized text for the conversation
}
"""


# Pydantic Models
class ChatMessage(BaseModel):
    conversation_id: str
    user_id: str
    content: str
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class MessageResponse(BaseModel):
    message_id: str
    conversation_id: str
    user_id: str
    content: str
    timestamp: datetime
    
class SummarizationRequest(BaseModel):
    conversation_id: str

class SummaryResponse(BaseModel):
    conversation_id: str
    summary_text: str

# Creating API Endpoints

@app.post("/chats", response_model=MessageResponse)
async def store_chat_message(chat: ChatMessage):

    #Store a chat message in the database.
    message_doc = {
        "conversation_id": chat.conversation_id,
        "user_id": chat.user_id,
        "content": chat.content,
        "timestamp": chat.timestamp,
    }
    result = await messages_collection.insert_one(message_doc)

    # Prepare response
    message_doc["message_id"] = str(result.inserted_id)
    return message_doc

@app.get("/chats/{conversation_id}", response_model=List[MessageResponse])
async def retrieve_chat_messages(
    conversation_id: str,
    keyword: Optional[str] = Query(None, description="Filter messages containing this keyword"),
    start_date: Optional[datetime] = Query(None, description="Start date for filtering messages"),
    end_date: Optional[datetime] = Query(None, description="End date for filtering messages"),
    limit: int = Query(50, ge=1, le=100, description="Limit number of messages to fetch")
):

    # Retrieve messages from a specific conversation, with optional keyword and date filters.

    query = {"conversation_id": conversation_id}

    if keyword:
        query["$text"] = {"$search": keyword}  # Text search on content

    if start_date or end_date:
        date_filter = {}
        if start_date:
            date_filter["$gte"] = start_date
        if end_date:
            date_filter["$lte"] = end_date
        query["timestamp"] = date_filter

    messages = []
    async for message in messages_collection.find(query).sort("timestamp", -1).limit(limit):
        message["message_id"] = str(message["_id"])
        messages.append(message)

    if not messages:
        raise HTTPException(status_code=404, detail="No messages found")

    return messages

@app.get("/users/{user_id}/chats", response_model=List[MessageResponse])
async def get_user_chat_history(
    user_id: str,
    page: int = Query(1, ge=1, description="Page number"),
    limit: int = Query(10, ge=1, le=50, description="Messages per page")
):

    # Retrieve a paginated list of chat messages for a given user.

    skip = (page - 1) * limit
    query = {"user_id": user_id}

    messages = []
    async for message in messages_collection.find(query).sort("timestamp", -1).skip(skip).limit(limit):
        message["message_id"] = str(message["_id"])
        messages.append(message)

    if not messages:
        raise HTTPException(status_code=404, detail="No chat history found for this user")

    return messages

@app.delete("/chats/{conversation_id}")
async def delete_chat(conversation_id: str):

    # Delete an entire conversation and all its messages.

    delete_result = await messages_collection.delete_many({"conversation_id": conversation_id})

    if delete_result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Conversation not found")

    return {"message": f"Deleted {delete_result.deleted_count} messages from conversation '{conversation_id}'"}


@app.post("/chats/summarize", response_model=SummaryResponse)
async def summarize_chat(request: SummarizationRequest):
    """
    Summarizes a conversation by its ID using the Hugging Face API.
    It fetches all messages in the conversation (sorted by timestamp),
    then constructs a string with user IDs, messages, and timestamps,
    and finally sends it to the Hugging Face summarization API.
    """
    
    # Fetch all messages for the given conversation id, sorted by timestamp (oldest first)
    query = {"conversation_id": request.conversation_id}
    messages_cursor = messages_collection.find(query).sort("timestamp", 1)
    
    messages = []
    async for message in messages_cursor:
        # Formatind the text
        #time_str = message["timestamp"].strftime("%Y-%m-%d %H:%M:%S")
        formatted = f" {message['user_id']}: {message['content']}"
        messages.append(formatted)
    messages.pop()
    #print(messages)
    
    if not messages:
        raise HTTPException(status_code=404, detail="No messages found for the conversation")
    
    # Join all messages into a single conversation string
    conversation_text = text = '\n'.join(unicodedata.normalize("NFKC", line.strip()) for line in messages) 
    # print(conversation_text)
    
    if not HF_API_KEY:
        raise HTTPException(status_code=500, detail="Hugging Face API key is not found")

    headers = {"Authorization": f"Bearer {HF_API_KEY}"}
    HF_SUMMARIZATION_URL = "https://api-inference.huggingface.co/models/facebook/bart-large-cnn"
    data = {
        "inputs": conversation_text,
        "parameters": {
            "max_length": 500,
            "min_length": 30,
            "do_sample": False
        }
    }

    response = requests.post(HF_SUMMARIZATION_URL, headers=headers, json=data)
    print(response.json())

    if response.status_code != 200:
        raise HTTPException(status_code=500, detail="Error from Hugging Face API")

    summary_result = response.json()
    try:
        summary_text = summary_result[0]["summary_text"]
    except (IndexError, KeyError):
        raise HTTPException(status_code=500, detail="Unexpected response format from Hugging Face API")

    summary_doc = {"conversation_id": request.conversation_id, "summary_text": summary_text}
    await summaries_collection.update_one(
        {"conversation_id": request.conversation_id},
        {"$set": summary_doc},
        upsert=True
    )
    
    return summary_doc


@app.get("/summaries/{conversation_id}", response_model=SummaryResponse)
async def get_summary(conversation_id: str):
    summary = await summaries_collection.find_one({"conversation_id": conversation_id})
    if not summary:
        raise HTTPException(status_code=404, detail="Summary not found")
    return {"conversation_id": summary["conversation_id"], "summary_text": summary["summary_text"]}

# ---------------------------


